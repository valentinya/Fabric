{"version":3,"sources":["utilities/parser/BaseParser.ts"],"names":[],"mappings":"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","file":"utilities/parser/BaseParser.js","sourcesContent":["\n/**\n * Base for a parser - does not actually do any parsing.\n */\nexport class BaseParser {\n  private _currLocation = 0;\n  private _str: string;\n  private _strLength: number;\n\n  public constructor(_str: string) {\n    this._str = _str;\n    this._strLength = _str.length;\n  }\n\n  protected eat(match: string): string {\n    if (this._str.charAt(this._currLocation) === match) {\n      return this._str.charAt(this._currLocation++);\n    }\n\n    return undefined;\n  }\n\n  protected eatSpacesAndNewlines(): string {\n    return this.eatWhileRegex(/[ \\r\\n]/);\n  }\n\n  protected eatWhile(match: string): string {\n    let i = 0;\n\n    while (this._str.charAt(this._currLocation + i) === match) {\n      i++;\n      if (i + this._currLocation > this._strLength) {\n        break;\n      }\n    }\n\n    this._currLocation += i;\n    return this._str.substr(this._currLocation - i, i);\n  }\n\n  protected eatWhileRegex(match: RegExp): string {\n    let i = 0;\n\n    while (match.test(this._str.charAt(this._currLocation + i))) {\n      i++;\n      if (i + this._currLocation > this._strLength) {\n        break;\n      }\n    }\n\n    this._currLocation += i;\n    return this._str.substr(this._currLocation - i, i);\n  }\n\n  protected eatWord(word: string): string {\n    let len = word.length;\n\n    if (this.peekAhead(len) === word) {\n      this._currLocation += len;\n      return word;\n    }\n\n    return undefined;\n  }\n\n  protected eatUntil(match: RegExp): string {\n    let i = 0;\n\n    while (!match.test(this._str.charAt(this._currLocation + i))) {\n      i++;\n      if (i + this._currLocation > this._strLength) {\n        break;\n      }\n    }\n\n    this._currLocation += i;\n    return this._str.substr(this._currLocation - i, i);\n  }\n\n  protected peek(): string {\n    return this._str.charAt(this._currLocation);\n  }\n\n  protected peekAhead(by: number): string {\n    return this._str.substr(this._currLocation, by);\n  }\n\n  protected hasNext(): boolean {\n    return this._currLocation < this._strLength - 1;\n  }\n\n  /**\n   * Advances the stream if possible.\n   *\n   * @protected\n   * @returns {string} The token that was advanced over, or undefined if it wasn't possible to advance.\n   */\n  protected next(): string {\n    if (this.hasNext()) {\n      return this._str.charAt(this._currLocation++);\n    }\n\n    return undefined;\n  }\n\n  protected reset(): void {\n    this._currLocation = 0;\n  }\n}\n"],"sourceRoot":"..\\..\\..\\src"}