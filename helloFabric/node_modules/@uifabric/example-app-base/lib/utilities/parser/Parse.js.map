{"version":3,"sources":["utilities/parser/Parse.ts"],"names":[],"mappings":";AAAA,2CAAuD;AACvD,iEAAgE;AAChE,uDAAsD;AAEtD;;;;;;;;;;;;;;GAcG;AACH,eAAsB,MAAc,EAAE,wBAAiC;IACrE,IAAI,KAAK,GAAgB,EAAE,CAAC;IAC5B,IAAI,KAAK,GAAW,IAAI,CAAC;IACzB,IAAI,SAAS,CAAC;IAEd,IAAI,kBAAkB,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,YAAY,GAAG,OAAO,EAA7C,CAA6C,CAAC;IACzF,IAAI,YAAY,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,yBAAY,CAAC,SAAS,GAAG,yBAAY,CAAC,IAAI,EAAjE,CAAiE,CAAC;IAEvG,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;QAC7B,KAAK,GAAG,IAAI,MAAM,CAAC,6BAA2B,wBAAwB,4CAAyC,CAAC,CAAC;QACjH,IAAI,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACrC,EAAE,CAAC,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC1C,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,CAAC,CAAY;oBACjB,IAAI,EAAE,wBAAwB;oBAC9B,YAAY,EAAE,wBAAwB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC3E,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC1C,QAAQ,EAAE,SAAS;iBACpB,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,KAAK,GAAG,IAAI,MAAM,CAAC,wEAAwE,EAAE,GAAG,CAAC,CAAC;QAClG,IAAI,WAAW,SAAiB,CAAC;QACjC,IAAI,OAAO,GAAqB,EAAE,CAAC;QACnC,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YACnD,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;YAC/C,OAAO,CAAC,IAAI,CAAY;gBACtB,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;gBACpB,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBACjE,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC1C,QAAQ,EAAE,SAAS;aACpB,CAAC,CAAC;QACL,CAAC;QAED,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAED,MAAM,CAAC,KAAK,CAAC;AACf,CAAC;AAtCD,sBAsCC;AAED,+BAA+B,WAA4B;IACzD,IAAI,SAAS,CAAC;IACd,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC;QACnC,IAAI,MAAM,GAAG,IAAI,6CAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QACvD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAC3B,MAAM,GAAG,IAAI,CAAC;IAChB,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,IAAI,MAAM,GAAG,IAAI,mCAAgB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QAClD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAC3B,MAAM,GAAG,IAAI,CAAC;IAChB,CAAC;IACD,MAAM,CAAC,SAAS,CAAC;AACnB,CAAC","file":"utilities/parser/Parse.js","sourcesContent":["import { IProperty, PropertyType } from './interfaces';\nimport { InterfaceParserHelper } from './InterfaceParserHelper';\nimport { EnumParserHelper } from './EnumParserHelper';\n\n/**\n * Given some valid, well linted Typescript source code, extracts exported interfaces and enums.\n *\n * Note: requires that the closing '}' of interfaces and enums is the first char on its own line.\n *       It should otherwise be reasonably robust to handle various commenting or even code layout\n *       styles within the interface or enum.\n *\n * To specify default values for interfaces, use the JSDoc @default or @defaultvalue markup.\n * The rest of the line after @default will be captured as the default value.\n *\n * @export\n * @param {string} source Valid, reasonably well linted Typescript source code.\n * @param {string} [propsInterfaceOrEnumName] Name of an interface or enum if you only want to parse said interface or enum.\n * @returns {Array<IProperty>} An array of properties.\n */\nexport function parse(source: string, propsInterfaceOrEnumName?: string): IProperty[] {\n  let props: IProperty[] = [];\n  let regex: RegExp = null;\n  let parseInfo;\n\n  let propertyNameSuffix = (type: string) => type === 'interface' ? ' interface' : ' enum';\n  let propertyType = (type: string) => type === 'interface' ? PropertyType.interface : PropertyType.enum;\n\n  if (propsInterfaceOrEnumName) {\n    regex = new RegExp(`export (interface|enum) ${propsInterfaceOrEnumName}(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`);\n    let regexResult = regex.exec(source);\n    if (regexResult && regexResult.length > 0) {\n      parseInfo = _parseEnumOrInterface(regexResult);\n      return [<IProperty>{\n        name: propsInterfaceOrEnumName,\n        propertyName: propsInterfaceOrEnumName + propertyNameSuffix(regexResult[1]),\n        propertyType: propertyType(regexResult[1]),\n        property: parseInfo\n      }];\n    }\n  } else {\n    regex = new RegExp(`export (interface|enum) (\\\\S*?)(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`, 'g');\n    let regexResult: RegExpExecArray;\n    let results: Array<IProperty> = [];\n    while ((regexResult = regex.exec(source)) !== null) {\n      parseInfo = _parseEnumOrInterface(regexResult);\n      results.push(<IProperty>{\n        name: regexResult[2],\n        propertyName: regexResult[2] + propertyNameSuffix(regexResult[1]),\n        propertyType: propertyType(regexResult[1]),\n        property: parseInfo\n      });\n    }\n\n    return results;\n  }\n\n  return props;\n}\n\nfunction _parseEnumOrInterface(regexResult: RegExpExecArray) {\n  let parseInfo;\n  if (regexResult[1] === 'interface') {\n    let parser = new InterfaceParserHelper(regexResult[0]);\n    parseInfo = parser.parse();\n    parser = null;\n  } else {\n    let parser = new EnumParserHelper(regexResult[0]);\n    parseInfo = parser.parse();\n    parser = null;\n  }\n  return parseInfo;\n}\n"],"sourceRoot":"..\\..\\..\\src"}